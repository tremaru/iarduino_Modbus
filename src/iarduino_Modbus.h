//	Библиотека для работы по протоколу Modbus.
//  Версия: 1.0.1
//  Последнюю версию библиотеки Вы можете скачать по ссылке: http://iarduino.ru/
//  Подробное описание функции бибилиотеки доступно по ссылке: https://wiki.iarduino.ru/
//  Библиотека является собственностью интернет магазина iarduino.ru и может свободно использоваться и распространяться!
//  При публикации устройств или скетчей с использованием данной библиотеки, как целиком, так и её частей,
//  в том числе и в некоммерческих целях, просим Вас опубликовать ссылку: http://iarduino.ru
//  Автор библиотеки: Панькин Павел
//  Если у Вас возникли технические вопросы, напишите нам: shop@iarduino.ru

#ifndef iarduino_Modbus_h
#define iarduino_Modbus_h

#if defined(ARDUINO) && (ARDUINO >= 100)
#include <Arduino.h>
#else
#include <WProgram.h>
#endif

#define	MODBUS_ADU_MAX				256																//	Размер буфера для приема передачи пакетов ADU протокола Modbus RTU/ASCII.
																									//
#define	MODBUS_RTU					1																//	Аргумент для функции begin() указывающий тип передачи данных Modbus RTU.
#define	MODBUS_ASCII				2																//	Аргумент для функции begin() указывающий тип передачи данных Modbus ASCII.
#define COILS						0																//	Аргумент для функции requestFrom() и beginTransmission() указывающий тип регистра.
#define DISCRETE_INPUTS				1																//	Аргумент для функции requestFrom()                       указывающий тип регистра.
#define HOLDING_REGISTERS			2																//	Аргумент для функции requestFrom() и beginTransmission() указывающий тип регистра.
#define INPUT_REGISTERS				3																//	Аргумент для функции requestFrom()                       указывающий тип регистра.
#define DEVICE_MB_ABSENT			0																//	Значение возвращаемое функцией checkID() - Нет устройств с указанным адресом.
#define DEVICE_MB_DOUBLE			1																//	Значение возвращаемое функцией checkID() - Адрес принадлежит двум и более устройствам.
#define DEVICE_MB_UNKNOWN			2																//	Значение возвращаемое функцией checkID() - Адрес принадлежит устройству не iarduino.
#define DEVICE_MB_IARDUINO			3																//	Значение возвращаемое функцией checkID() - Адрес принадлежит устройству линейки iarduino.
#define ERROR_ILLEGAL_FUNCTION		1																//	Значение возвращаемое функцией lastError() - Ошибка команды. Номер команды или функции в запросе неизвестен модулю или не может быть обработан.
#define ERROR_ILLEGAL_ADDRESS		2																//	Значение возвращаемое функцией lastError() - Ошибка адреса. Адрес регистра в запросе лежит за пределами диапазона.
#define ERROR_ILLEGAL_VALUE			3																//	Значение возвращаемое функцией lastError() - Ошибка данных. Недопустимое значение в поле данных запроса.
#define ERROR_DEVICE_FAILURE		4																//	Значение возвращаемое функцией lastError() - Иная ошибка. Любая невосстановимая ошибка кроме первых трёх.
#define ERROR_ACKNOWLEDGE			5																//	Значение возвращаемое функцией lastError() - Запрос принят, но на обработку требуется время. Предупреждение для мастера.
#define ERROR_DEVICE_BUSY			6																//	Значение возвращаемое функцией lastError() - Ведомый занят, запрос проигнорирован. Повторите запрос позже.
#define ERROR_MEMORY_PARITY			8																//	Значение возвращаемое функцией lastError() - Ошибка чтения/записи файла.
#define ERROR_GATEWAY_UNAVAILABLE	10																//	Значение возвращаемое функцией lastError() - Шлюз неправильно настроен или перегружен запросами.
#define ERROR_GATEWAY_NO_DEVICE		11																//	Значение возвращаемое функцией lastError() - Slave устройства нет в сети или от него нет ответа.
#define ERROR_SYNTAX				249																//	Значение возвращаемое функцией lastError() - Ошибка синтаксиса.
#define ERROR_ADR_IARDUINO			250																//	Значение возвращаемое функцией lastError() - Ошибка назначения или сортировки адресов устройств iarduino.
#define ERROR_ADR_RESPONSE			251																//	Значение возвращаемое функцией lastError() - Несовпадение адреса регистра в ответе.
#define ERROR_VAL_RESPONSE			252																//	Значение возвращаемое функцией lastError() - Несовпадение данных в ответе.
#define ERROR_CRC_RESPONSE			253																//	Значение возвращаемое функцией lastError() - Несовпадение CRC в принятом ответе.
#define ERROR_LEN_REQUEST			254																//	Значение возвращаемое функцией lastError() - Размер отправляемого запроса превышает размер буфера MODBUS_ADU_MAX или максимальный размер пакета ADU.
#define ERROR_LEN_RESPONSE			255																//	Значение возвращаемое функцией lastError() - Размер полученного ответа превышает размер буфера MODBUS_ADU_MAX или не соответствует ожидаемому размеру.
																									//
class ModbusClient{																					//
	public:																							//
	/**	Конструктор класса **/																		//
					ModbusClient			(Stream &obj, uint8_t pin=0xFF						);	//	Объявляем конструктор класса.															Параметры функции: &obj ссылка на объект для работы с аппаратным или программным UART, pin - № вывода Arduino к которому подключён вывод DE конвертера UART - RS485.
	/**	Пользовательские функции **/																//
		void		begin					(void												);	//	Объявляем функцию инициализации работы по протоколу Modbus.								Параметры функции: нет.
		void		setTypeMB				(uint8_t type										)		{ typeModbus=type; } // Определяем функцию установки типа протокола Modbus.				Параметры функции: type тип протокола MODBUS_RTU/MODBUS_ASCII.
		uint8_t		searchERR				(void												);	//	Объявляем функцию обнаружения устройств iarduino с одинаковыми адресами.				Параметры функции: нет. Функция возвращает количество найденных ID, доступных для чтения функцией read() и available().
		uint8_t		findID					(uint8_t mod=0										);	//	Объявляем функцию поиска всех ID, а если mod!=0 то только ID iarduino указанной модели.	Параметры функции: модель. Функция возвращает количество найденных ID, доступных для чтения функцией read() и available().
		int16_t		sortID					(uint8_t start=1									);	//	Объявляем функцию изменения ID устройств iarduino.										Параметры функции: первый адрес в новом списке устройств. Функция возвращает количество устройств которым был изменён ID, или -1 при неудаче.
		uint8_t		checkID					(uint8_t											);	//	Объявляем функцию проверки устройств.													Параметры функции: SlaveID 1-255. Возвращает DEVICE_MB_ABSENT/DEVICE_MB_DOUBLE/DEVICE_MB_UNKNOWN/DEVICE_MB_IARDUINO.
		bool		changeID				(uint8_t nowID, uint8_t newID						);	//	Объявляем функцию сохранения нового ID для устройства iarduino.							Параметры функции: текущий id модуля, новый id модуля. Функция возвращает результат сохранения адреса (0/1).
		int8_t		coilRead				(uint8_t id, uint16_t reg							);	//	Объявляем функцию чтения одного регистра "Coil" (DO).									Параметры функции: id модуля, адрес регистра. Функция возвращает прочитанное значение (0/1), или -1 при неудаче.
		int8_t		coilRead				(            uint16_t reg							)		{ return coilRead(0, reg); }
		int8_t		discreteInputRead		(uint8_t id, uint16_t reg							);	//	Объявляем функцию чтения одного регистра "Discrete Input" (DI).							Параметры функции: id модуля, адрес регистра. Функция возвращает прочитанное значение (0/1), или -1 при неудаче.
		int8_t		discreteInputRead		(            uint16_t reg							)		{ return discreteInputRead(0, reg); }
		int32_t		holdingRegisterRead		(uint8_t id, uint16_t reg							);	//	Объявляем функцию чтения одного регистра "Holding Register" (AO).						Параметры функции: id модуля, адрес регистра. Функция возвращает прочитанное значение (0...65535), или -1 при неудаче.
		int32_t		holdingRegisterRead		(            uint16_t reg							)		{ return holdingRegisterRead(0, reg); }
		int32_t		inputRegisterRead		(uint8_t id, uint16_t reg							);	//	Объявляем функцию чтения одного регистра "Input Register" (AI).							Параметры функции: id модуля, адрес регистра. Функция возвращает прочитанное значение (0...65535), или -1 при неудаче.
		int32_t		inputRegisterRead		(            uint16_t reg							)		{ return inputRegisterRead(0, reg); }
		bool		coilWrite				(uint8_t id, uint16_t reg, bool val					);	//	Объявляем функцию записи в один регистр  "Coil" (DO).									Параметры функции: id модуля, адрес регистра, значение (0/1). Функция возвращает 1 при успехе, 0 при неудаче.
		bool		coilWrite				(            uint16_t reg, bool val					)		{ return coilWrite(0, reg, val); }
		bool		holdingRegisterWrite	(uint8_t id, uint16_t reg, uint16_t val				);	//	Объявляем функцию записи в один регистр  "Holding Register" (AO).						Параметры функции: id модуля, адрес регистра, значение (0...65535). Функция возвращает 1 при успехе, 0 при неудаче.
		bool		holdingRegisterWrite	(            uint16_t reg, uint16_t val				)		{ return holdingRegisterWrite(0, reg, val); }
		bool		registerMaskWrite		(uint8_t id, uint16_t reg, uint16_t a  , uint16_t o	);	//	Объявляем функцию записи масок в один регистр "Holding Register" (AO).					Параметры функции: id модуля, адрес регистра, маска AND, маска OR. Функция возвращает 1 при успехе, 0 при неудаче.
		bool		registerMaskWrite		(            uint16_t reg, uint16_t a  , uint16_t o	)		{ return registerMaskWrite(0, reg, a, o); }
		bool		beginTransmission		(uint8_t id, uint8_t type, uint16_t reg, uint16_t n	);	//	Объявляем функцию инициализации записи в несколько регистров (DO) или (AO).				Параметры функции: id модуля, тип регистра (COILS/HOLDING_REGISTERS), адрес первого регистра, количество регистров. Функция возвращает 1 при успехе, 0 при неудаче.
		bool		beginTransmission		(            uint8_t type, uint16_t reg, uint16_t n	)		{ return beginTransmission(0, type, reg, n); }
		uint16_t	requestFrom				(uint8_t id, uint8_t type, uint16_t reg, uint16_t n	);	//	Объявляем функцию выполнения чтения из нескольких регистров (DO), (DI), (AO), (AI).		Параметры функции: id модуля, тип регистра (COILS/DISCRETE_INPUTS/HOLDING_REGISTERS/INPUT_REGISTERS), адрес первого регистра, количество регистров. Функция возвращает количество прочитанных значений, или 0 при неудаче.
		uint16_t	requestFrom				(            uint8_t type, uint16_t reg, uint16_t n	)		{ return requestFrom(0, type, reg, n); }
		bool		write					(uint16_t val										);	//	Объявляем функцию постановки значения в очередь на запись после beginTransmission().	Параметры функции: очередное значение для записи.
		bool		endTransmission			(void												);	//	Объявляем функцию выполнения записи в несколько регистров (DO) или (AO).				Параметры функции: нет. Функция возвращает 1 при успехе, 0 при неудаче.
		uint16_t	available				(void												)		{ return requestCNT; } // Получения количества значений, доступных для чтения.			Параметры функции: нет. Функция возвращает количество значений, доступных для чтения функцией read().
		int32_t		read					(void												);	//	Объявляем функцию чтения очередного полученного значения после requestFrom(),...		Параметры функции: нет. Функция возвращает значение (0/1/0...65535), или -1 при неудаче.
		void		end						(void												);	//	Объявляем функцию остановки клиента и очистки буфера.									Параметры функции: нет.
		uint8_t		lastError				(void												)		{ return codeError; } // Определяем функцию получения кода причины последней ошибки.	Параметры функции: нет. Функция возвращает код причины последней ошибки.
		void		setTimeout				(uint32_t ms										)		{ valTimeoutGET=ms; } // Определяем функцию установки времени ожидания ответа (в мс).	Параметры функции: время в мс.
		void		setDelay				(uint32_t ms										)		{ valTimeoutSET=ms; } // Определяем функцию установки интервала сообщений (в мс).		Параметры функции: время в мс.
		int16_t		exceptionStatusRead		(uint8_t id=0										);	//	Объявляем функцию чтения состояния 8 статусных выходов.									Параметры функции: id модуля. Функция возвращает байт битов, или -1 при неудаче.
		int8_t		getSate					(uint8_t id=0										);	//	Объявляем функцию чтения состояния устройства.											Параметры функции: id модуля. Функция возвращает бит состояния (0-свободно,1-занято), или -1 при неудаче.
		int32_t		getEventCounter			(uint8_t id=0										);	//	Объявляем функцию чтения счетчика событий (успешно выполненых запросов).				Параметры функции: id модуля. Функция возвращает значение счётчика событий, или -1 при неудаче.
		uint8_t		getEventLog				(uint8_t id=0										);	//	Объявляем функцию чтения журнала событий.												Параметры функции: id модуля. Функция возвращает количество данных, доступных для чтения функцией read() и available().
		int32_t		diagnostic				(uint8_t id, uint16_t func, uint16_t data=0			);	//	Объявляем функцию выполнения команды диагностики.										Параметры функции: id модуля, номер функции диагностики, данные. Функция возвращает данные результата выполнения функции диагностики, или -1 при неудаче.
		uint8_t		getInfo					(uint8_t id=0										);	//	Объявляем функцию чтения информации об устройстве.										Параметры функции: id модуля. Функция возвращает количество байт данных об устройстве, доступных для чтения функцией read() и available().
	/**	Пользовательские переменные **/																//
		char		charASCII='\n';																	//	Определяем переменную для хранения последнего символа пакета ADU для MODBUS_ASCII.		Этот символ можно изменить командой diagnostic(id, 3, ...)
		uint8_t		codeError=0;																	//	Определяем переменную для хранения кода причины последней ошибки.						ERROR_ILLEGAL_FUNCTION/ERROR_ILLEGAL_ADDRESS/...
																									//	
	private:																						//	
	/**	Внутренние функции **/																		//
		bool		_rwADU					(void												);	//	Объявляем  функцию отправки/получения данных из/в массив arrADU длиной lenADU байт.		Функция сама добавляет CRC к передаваемым данным. Данные arrADU хранятся в формате RTU. Функция возвращает флаг успеха приёма/передачи.
		uint8_t		_num					(char												);	//	Объявляем  функцию преобразования символа в число.										Параметры функции: символ 0-9,a-f,A-F.
		char		_char					(uint8_t											);	//	Объявляем  функцию преобразования числа в символ.										Параметры функции: число 0-15.
		void		_crc16					(uint8_t											);	//	Объявляем  функцию рассчёта CRC-16 из arrADU. Результат сохраняется в valCRC			Параметры функции: количество байт в arrADU.
		bool		_waitTo					(uint32_t											);	//	Объявляем  функцию ожидания времени с момента timEndPack.								Параметры функции: количество миллисекунд. Функция возвращает true в течении указанных миллисекунд с момента timEndPack.
	/**	Внутренние переменные **/																	//
		Stream*		objSerial;																		//	Объявляем  указатель на объект работы с UART.											Serial, Serial1, ..., SoftwareSerial.
		uint8_t		pinDE;																			//	Объявляем  переменную для хранения номера вывода DE.									Число.
		uint8_t		typeModbus=MODBUS_RTU;															//	Определяем переменную для хранения типа передачи данных.								MODBUS_RTU, MODBUS_ASCII.
volatile uint32_t	timEndPack=0;																	//	Определяем переменную для хранения времени отправки/получения последнего пакета			Миллисекунды.
		uint32_t	valTimeoutGET=10;																//	Определяем переменную для хранения максимального времени ожидания ответа				Миллисекунды.
		uint32_t	valTimeoutSET=3;																//	Определяем переменную для хранения минимального  времени ожидания передачи				Миллисекунды.
		uint8_t		arrADU[MODBUS_ADU_MAX];															//	Объявляем  буфер приёма передачи пакетов ADU.
		uint16_t	lenADU;																			//	Объявляем  переменную для хранения количества байт в буфере arrADU.
		uint16_t	valCRC;																			//	Объявляем  переменную для хранения CRC рассчитанного функцией _crc16().
		bool		transmissionFLG=false;															//	Определяем флаг инициализации записи в несколько регистров beginTransmission().			Флаг сбрасывается при отправке любого запроса.
		uint16_t	transmissionCNT;																//	Объявляем  счётчик вызова функций write().												Обнуляется обращением к функции beginTransmission().
		uint16_t	requestSUM;																		//	Объявляем  переменную для хранения количества значений прочитанных requestFrom().		Устанавливается обращением к функции requestFrom().
		uint16_t	requestCNT;																		//	Объявляем  счётчик количества оставшихся обращений к функций read().					Устанавливается обращением к функции requestFrom(). Уменьшается обращением к функции read(). Сбрасывается при отправке любого запроса.
};

#endif